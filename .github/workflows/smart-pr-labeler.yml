name: Smart PR Labeler (change-type + content-type)

on:
  pull_request_target:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  smart-label:
    runs-on: ubuntu-latest
    steps:
      - name: Smartly label PR based on changed files
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;
            if (!prNumber) {
              core.setFailed("No pull request number found in context.");
              return;
            }

            // fetch changed files on the PR (via API)
            let page = 1;
            const per_page = 100;
            let allFiles = [];
            while (true) {
              const resp = await github.rest.pulls.listFiles({
                owner, repo, pull_number: prNumber, page, per_page
              });
              if (!resp || !resp.data) break;
              allFiles = allFiles.concat(resp.data);
              if (resp.data.length < per_page) break;
              page++;
            }

            if (!allFiles.length) {
              core.info("No files found on PR â€” nothing to label.");
              return;
            }

            // Determine change-type labels
            const changeTypeMap = { added: "added", modified: "modified", removed: "deleted", renamed: "renamed" };
            const changeLabels = new Set();
            for (const f of allFiles) {
              const st = (f.status || "").toLowerCase();
              if (changeTypeMap[st]) changeLabels.add(changeTypeMap[st]);
              if (st === "changed") changeLabels.add("modified");
            }

            // Determine content-type labels from file paths/extensions
            const contentLabels = new Set();
            for (const f of allFiles) {
              const p = (f.filename || "").toLowerCase();

              if (p.endsWith(".md") || p.startsWith("docs/") || p.includes("/docs/")) contentLabels.add("docs");
              if (p.endsWith(".sql")) contentLabels.add("sql");
              if (p.endsWith(".py") || p.endsWith(".ipynb")) contentLabels.add("python");
              if (p.includes("dbt/") || p.includes("models/") || (p.endsWith(".sql.jinja") || (p.endsWith(".yml") && p.includes("dbt")))) contentLabels.add("dbt");
              if (p.endsWith(".yml") || p.endsWith(".yaml") || p.startsWith(".github/") || p.includes("/.github/") || p.includes("workflow")) contentLabels.add("config");
              if (p.includes("test_") || p.includes("/tests/") || p.endsWith(".spec.js") || p.endsWith(".test.py")) contentLabels.add("tests");
              if (p.endsWith(".json")) contentLabels.add("json");
              if (p.endsWith(".ipynb")) contentLabels.add("notebook");
            }

            const finalLabelsSet = new Set([...changeLabels, ...contentLabels]);
            if (finalLabelsSet.size === 0) finalLabelsSet.add("other");
            const finalLabels = Array.from(finalLabelsSet);
            core.info("Will apply labels: " + finalLabels.join(", "));

            // Create missing labels if they don't exist
            const colorMap = {
              added: "1abc9c", modified: "f1c40f", deleted: "e74c3c", renamed: "9b59b6",
              docs: "0366d6", sql: "2b9348", python: "3572A5", dbt: "ff7b00",
              config: "6f42c1", tests: "dbb40c", json: "f39c12", notebook: "f5b041", other: "95a5a6"
            };

            // fetch existing labels
            let repoLabels = [];
            try {
              let pageL = 1;
              while (true) {
                const lresp = await github.rest.issues.listLabelsForRepo({ owner, repo, per_page: 100, page: pageL });
                repoLabels = repoLabels.concat(lresp.data.map(l => l.name.toLowerCase()));
                if (lresp.data.length < 100) break;
                pageL++;
              }
            } catch (err) {
              core.warning("Could not list labels: " + err.message);
            }

            for (const lbl of finalLabels) {
              if (!repoLabels.includes(lbl.toLowerCase())) {
                try {
                  const color = colorMap[lbl] || "ededed";
                  await github.rest.issues.createLabel({ owner, repo, name: lbl, color, description: `Auto-created label: ${lbl}` });
                  core.info(`Created label: ${lbl}`);
                } catch (err) {
                  core.warning(`Could not create label ${lbl}: ${err.message}`);
                }
              }
            }

            // Apply labels to PR
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: finalLabels });
              core.info("Labels added to PR #" + prNumber);
            } catch (err) {
              core.setFailed("Failed to add labels to PR: " + err.message);
            }
