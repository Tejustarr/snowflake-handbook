name: Smart PR Labeler (change-type + content-type)

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  smart-label:
    runs-on: ubuntu-latest
    steps:
      - name: Smartly label PR based on changed files
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;
            if (!prNumber) {
              core.setFailed("No pull request number found in context.");
              return;
            }

            // fetch changed files on the PR (handles pagination)
            let page = 1;
            const per_page = 100;
            let allFiles = [];
            while (true) {
              const resp = await github.rest.pulls.listFiles({
                owner, repo, pull_number: prNumber, page, per_page
              });
              if (!resp || !resp.data) break;
              allFiles = allFiles.concat(resp.data);
              if (resp.data.length < per_page) break;
              page++;
            }

            if (!allFiles.length) {
              core.info("No files found on PR — nothing to label.");
              return;
            }

            // Determine change-type labels from file.status values:
            // status is one of: added, modified, removed, renamed, changed (varies)
            const changeTypeMap = {
              added: "added",
              modified: "modified",
              removed: "deleted",
              renamed: "renamed"
            };
            const changeLabels = new Set();
            for (const f of allFiles) {
              const st = (f.status || "").toLowerCase();
              if (changeTypeMap[st]) changeLabels.add(changeTypeMap[st]);
              // sometimes 'changed' or other values appear — treat as modified
              if (st === "changed") changeLabels.add("modified");
            }

            // Determine content-type labels from file paths/extensions
            const contentLabels = new Set();
            for (const f of allFiles) {
              const p = (f.filename || "").toLowerCase();

              if (p.endsWith(".md") || p.startsWith("docs/") || p.includes("/docs/")) {
                contentLabels.add("docs");
              }
              if (p.endsWith(".sql")) contentLabels.add("sql");
              if (p.endsWith(".py") || p.endsWith(".ipynb")) {
                // ipynb often maps to Python, include python label
                contentLabels.add("python");
              }
              if (p.includes("dbt/") || p.includes("models/") || p.endsWith(".sql.jinja") || p.endsWith(".yml") && p.includes("dbt")) {
                contentLabels.add("dbt");
              }
              if (p.endsWith(".yml") || p.endsWith(".yaml") || p.startsWith(".github/") || p.includes("/.github/") || p.includes("workflow")) {
                contentLabels.add("config");
              }
              if (p.includes("test_") || p.includes("/tests/") || p.endsWith(".spec.js") || p.endsWith(".test.py")) {
                contentLabels.add("tests");
              }
              if (p.endsWith(".json")) contentLabels.add("json");
              if (p.endsWith(".ipynb")) contentLabels.add("notebook");
              if (p.endsWith(".mdx")) contentLabels.add("docs");
              // add any other heuristics you like
            }

            // Combine labels (changes + content). If none content labels found, fallback to 'other'
            const finalLabelsSet = new Set([...changeLabels, ...contentLabels]);
            if (finalLabelsSet.size === 0) finalLabelsSet.add("other");

            const finalLabels = Array.from(finalLabelsSet);
            core.info("Will apply labels: " + finalLabels.join(", "));

            // Ensure labels exist in repo — create missing labels with default colors
            // Color map to make labels visually distinct (hex, without #)
            const colorMap = {
              added: "1abc9c",
              modified: "f1c40f",
              deleted: "e74c3c",
              renamed: "9b59b6",
              docs: "0366d6",
              sql: "2b9348",
              python: "3572A5",
              dbt: "ff7b00",
              config: "6f42c1",
              tests: "dbb40c",
              json: "f39c12",
              notebook: "f5b041",
              other: "95a5a6"
            };

            // fetch existing labels to avoid duplicates
            let repoLabels = [];
            try {
              let pageL = 1;
              while (true) {
                const lresp = await github.rest.issues.listLabelsForRepo({ owner, repo, per_page: 100, page: pageL });
                repoLabels = repoLabels.concat(lresp.data.map(l => l.name.toLowerCase()));
                if (lresp.data.length < 100) break;
                pageL++;
              }
            } catch (err) {
              core.warning("Could not list labels: " + err.message);
            }

            for (const lbl of finalLabels) {
              if (!repoLabels.includes(lbl.toLowerCase())) {
                try {
                  const color = colorMap[lbl] || "ededed";
                  await github.rest.issues.createLabel({
                    owner, repo, name: lbl, color, description: `Auto-created label: ${lbl}`
                  });
                  core.info(`Created label: ${lbl}`);
                } catch (err) {
                  core.warning(`Could not create label ${lbl}: ${err.message}`);
                }
              }
            }

            // Finally, add labels to the PR (issue)
            try {
              await github.rest.issues.addLabels({
                owner, repo,
                issue_number: prNumber,
                labels: finalLabels
              });
              core.info("Labels added to PR #" + prNumber);
            } catch (err) {
              core.setFailed("Failed to add labels to PR: " + err.message);
            }
